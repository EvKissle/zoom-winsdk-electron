#include "thread_routing.h"
#include <tlhelp32.h>

DWORD GetMainThreadId()
{
	DWORD processId = GetCurrentProcessId();
	DWORD threadId = 0;
	THREADENTRY32 te32 = { sizeof(te32) };
	HANDLE threadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	if (Thread32First(threadSnap, &te32))
	{
		do
		{
			if (processId == te32.th32OwnerProcessID)
			{
				threadId = te32.th32ThreadID;
				break;
			}
		} while (Thread32Next(threadSnap, &te32));
	}
	return threadId;
}

DWORD WINAPI CallBack2JSThreadFunction(LPVOID lpParam)
{
	if (lpParam)
	{
		CJSThreadMgr* pThreadMgr = (CJSThreadMgr*)lpParam;
		pThreadMgr->Callback2JSThreadProc();
	}

	return 0;
}

CJSThreadMgr::CJSThreadMgr()
{
	Reset();
}

CJSThreadMgr::~CJSThreadMgr()
{
	Uninit();
}

void CJSThreadMgr::Reset()
{
	m_bInit = false;
	m_dwMainThreadID = 0;
	m_hMainThreadCallWndProc = NULL;
	m_bExit = true;
	m_hWorkerEvent = NULL;
}

CJSThreadMgr& CJSThreadMgr::GetInstance()
{
	static CJSThreadMgr ob;
	return ob;
}

bool CJSThreadMgr::Init()
{
	if (!m_bInit)
	{
		m_dwMainThreadID = GetMainThreadId();
		m_workThreadAttach.Init(m_dwMainThreadID);
		m_callbackThreadAttach.Init(GetCurrentThreadId());
		m_hCallback2JSThread = CreateThread(
			NULL,                   // default security attributes
			0,                      // use default stack size  
			CallBack2JSThreadFunction,       // thread function name
			this,          // argument to thread function 
			0,                      // use default creation flags 
			NULL);   // returns the thread identifier 
		m_hWorkerEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		m_bExit = false;
		m_bInit = true;
		myOutputDebugStringW(L"CJSThreadMgr::Init-mainthreadid=%d,hookid=%d", m_dwMainThreadID, m_hMainThreadCallWndProc);
	}

	return m_bInit;
}
bool CJSThreadMgr::Uninit()
{
	m_workThreadAttach.Uninit();
	m_callbackThreadAttach.Uninit();

	m_bExit = true;
	if (m_hWorkerEvent)
		SetEvent(m_hWorkerEvent);
	if (m_hCallback2JSThread)
	{
		WaitForSingleObject(m_hCallback2JSThread, INFINITE);
	}
	if (m_hWorkerEvent)
	{
		CloseHandle(m_hWorkerEvent);
		m_hWorkerEvent = NULL;
	}
	if (m_hCallback2JSThread)
	{
		CloseHandle(m_hCallback2JSThread);
		m_hCallback2JSThread = NULL;
	}
	Reset();

	m_callbackTaskLock.Lock();
	std::list<IJSCallTask*>::iterator iter1 = m_callbackTaskList.begin();
	for (; m_callbackTaskList.end() != iter1; iter1++)
	{
		IJSCallTask* pTask = *iter1;
		if (pTask)
		{
			delete pTask;
		}
	}
	m_callbackTaskLock.Unlock();
	return true;
}

bool CJSThreadMgr::PostTask2JSThread(IJSCallTask* pTask)
{
	return m_callbackThreadAttach.PostMsg(pTask);
}

bool CJSThreadMgr::PostTask2WorkThread(IJSCallTask* pTask)
{
	return m_workThreadAttach.PostMsg(pTask);
}

bool CJSThreadMgr::PostTaks2CallBackThread(IJSCallTask* pTask)
{
	if (pTask)
	{
		m_callbackTaskLock.Lock();
		m_callbackTaskList.push_back(pTask);
		m_callbackTaskLock.Unlock();
		SetEvent(m_hWorkerEvent);
	}
	return true;
}

void CJSThreadMgr::Callback2JSThreadProc()
{
	while (m_hWorkerEvent && !m_bExit)
	{
		WaitForSingleObject(m_hWorkerEvent, INFINITE);

		if (m_bExit)
			break;

		BOOL bHasTask = TRUE;
		while (bHasTask && !m_bExit)
		{
			IJSCallTask* pTask = NULL;

			m_callbackTaskLock.Lock();

			if (m_callbackTaskList.empty())
			{
				bHasTask = FALSE;
			}
			else
			{
				std::list<IJSCallTask*>::iterator it = m_callbackTaskList.begin();
				if (it != m_callbackTaskList.end())
				{
					pTask = *it;
					m_callbackTaskList.erase(it);

					bHasTask = TRUE;
				}
			}

			m_callbackTaskLock.Unlock();

			if (pTask)
			{
				pTask->Run();
				delete pTask;
			}
		}
	}
}