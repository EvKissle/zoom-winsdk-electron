#ifndef _THREAD_ATTACH_H_
#define _THREAD_ATTACH_H_
#include <atlbase.h>
#include <list>
#include <set>
#define  WM_JS_WORK_MESSAGE (WM_USER + 10000)
inline void myOutputDebugString(const char* format, ...)
{
	//return;
	va_list args;
	va_start(args, format);
	char szData[2048] = { 0 };
	vsnprintf(szData, 2048, format, args);
	OutputDebugStringA(szData);
	va_end(args);
}
inline void myOutputDebugStringW(const wchar_t* format, ...)
{
	//return;
	va_list args;
	va_start(args, format);
	wchar_t szData[2048] = { 0 };
	_vsnwprintf(szData, 2048, format, args);
	OutputDebugStringW(szData);
	va_end(args);
}

class _LOG_FUNC_
{
public:
	_LOG_FUNC_(char* szFuncName)
	{
		if (szFuncName)
		{
			m_logstr = szFuncName;
			myOutputDebugString("%s->begin", szFuncName);
		}
	}
	~_LOG_FUNC_()
	{
		if (m_logstr.size() > 0)
		{
			myOutputDebugString("%s->end", m_logstr.c_str());
		}
	}

private:
	std::string m_logstr;
};

#define LOG_FUNC(FUNCNAME) _LOG_FUNC_ obxxx(FUNCNAME);

class IRetStore
{
public:
	virtual ~IRetStore() {}
	virtual bool HasRetValue() = 0;
};

class IJSCallTaskStautsNotify
{
public:
	virtual void onReturnVauleNotify(void* ret)
	{

	}
	virtual void onReturnVauleNotifyRTTI(IRetStore* ret)
	{

	}
};

class IJSCallTask
{
public:
	IJSCallTask()
	{
		m_callerThreadid = GetCurrentThreadId();
		m_hWaitEvent = NULL;
		m_pNotify = NULL;
	}
	virtual void SetWaitEvent(HANDLE hWaitEvent)
	{
		m_hWaitEvent = hWaitEvent;
	}

	virtual void SetNotifyHandler(IJSCallTaskStautsNotify* pNotify)
	{
		m_pNotify = pNotify;
	}

	virtual ~IJSCallTask() 
	{
		if (m_hWaitEvent)
		{ 
			SetEvent(m_hWaitEvent);
			m_hWaitEvent = NULL;
		}
		m_callerThreadid = 0;
	};
	virtual void Run() = 0;
	virtual IRetStore* GetRetValue() = 0;
	virtual void* GetRetValueNoRTTI() = 0;
	virtual DWORD GetCallerThreadID()
	{
		return m_callerThreadid;
	}
protected:
	DWORD m_callerThreadid;
	HANDLE m_hWaitEvent;
	IJSCallTaskStautsNotify* m_pNotify;
};

template<class T_PARAM>
class ParamRelease
{
public:
	virtual void release(T_PARAM& paRelease)
	{
	}
};

template<class  T_RET>
class RetVauleStore : public IRetStore
{
public:
	RetVauleStore()
	{
		m_bHas = false;
	}
	T_RET GetValue()
	{
		return m_ret;
	}

	void SetValue(T_RET ret)
	{
		m_ret = ret;
		m_bHas = true;
	}

	virtual bool HasRetValue()
	{
		return m_bHas;
	}

private:
	T_RET m_ret;
	bool m_bHas;
};

template<class T_RET>
class RetVauleStore<T_RET*> : public IRetStore
{
public:
	RetVauleStore()
	{
		m_bHas = false;
	}
	T_RET* GetValue()
	{
		return m_ret;
	}

	void SetValue(T_RET* ret)
	{
		m_ret = ret;
		m_bHas = true;
	}

	virtual bool HasRetValue()
	{
		return m_bHas;
	}

private:
	T_RET* m_ret;
	bool m_bHas;
};

template<>
class RetVauleStore<void> : public IRetStore
{
public:
	void GetValue()
	{
	}

	void SetValue(void)
	{
	}
	virtual bool HasRetValue()
	{
		return false;
	}
};

template<typename T>
struct RetTypeFlag
{
	typedef T type_;
};

template<>
struct RetTypeFlag<void>
{
	typedef void type_;
};

template<class T_PARAM>
class ParamRelease<T_PARAM*> : public ParamRelease<T_PARAM >
{
public:
	virtual void release(T_PARAM* paRelease)
	{
		if (NULL != paRelease)
		{
			delete paRelease;
			paRelease = NULL;
		}
	}
};

template<class T_CLASS, typename P_RETURN>
class TaskViaParam0 : public IJSCallTask
{
public:
	typedef P_RETURN(T_CLASS::*FuncType)();
	TaskViaParam0(T_CLASS* pTaskOwner, FuncType pFunc, bool bNeedReleaseParam)
	{
		m_pTaskOwner = pTaskOwner;
		m_pFunc = pFunc;
		m_bNeedReleaseParam = bNeedReleaseParam;
	}

	TaskViaParam0()
	{
		m_pTaskOwner = NULL;
		m_pFunc = NULL;
		m_bNeedReleaseParam = false;
	}

	virtual ~TaskViaParam0()
	{
		if (m_pNotify)
		{
			m_pNotify->onReturnVauleNotify(GetRetValueNoRTTI());
			m_pNotify->onReturnVauleNotifyRTTI(GetRetValue());
			delete m_pNotify;
		}
	}

	virtual void Run()
	{
		innerRun(RetTypeFlag<P_RETURN>());
	}

	template<typename Type>
	void innerRun(RetTypeFlag<Type>)
	{
		if (m_pTaskOwner && m_pFunc)
		{
			m_ret.SetValue(((*m_pTaskOwner).*m_pFunc)());
		}
	}

	void innerRun(RetTypeFlag<void>)
	{
		if (m_pTaskOwner && m_pFunc)
		{
			((*m_pTaskOwner).*m_pFunc)();
		}
	}

	virtual IRetStore* GetRetValue()
	{
		return &m_ret;
	}

	virtual void* GetRetValueNoRTTI()
	{
		return &m_ret;
	}

private:
	T_CLASS* m_pTaskOwner;
	FuncType m_pFunc;
	bool m_bNeedReleaseParam;
	RetVauleStore<P_RETURN> m_ret;
};


template<class T_CLASS, typename P_RETURN, typename P_PARAM0>
class TaskViaParam1 : public IJSCallTask
{
public:
	typedef P_RETURN(T_CLASS::*FuncType)(P_PARAM0);
	TaskViaParam1(T_CLASS* pTaskOwner, FuncType pFunc, P_PARAM0 param0, bool bNeedReleaseParam)
	{
		m_pTaskOwner = pTaskOwner;
		m_pFunc = pFunc;
		m_pParam0 = param0;
		m_bNeedReleaseParam = bNeedReleaseParam;
	}

	TaskViaParam1()
	{
		m_pTaskOwner = NULL;
		m_pFunc = NULL;
		m_pParam0 = NULL;
		m_bNeedReleaseParam = false;
	}

	virtual ~TaskViaParam1()
	{
		if (m_pNotify)
		{
			m_pNotify->onReturnVauleNotify(GetRetValueNoRTTI());
			m_pNotify->onReturnVauleNotifyRTTI(GetRetValue());
			delete m_pNotify;
		}
	}

	virtual void Run()
	{
		innerRun(RetTypeFlag<P_RETURN>());
	}

	template<typename Type>
	void innerRun(RetTypeFlag<Type>)
	{
		if (m_pTaskOwner && m_pFunc)
		{
			m_ret.SetValue(((*m_pTaskOwner).*m_pFunc)(m_pParam0));
		}

		if (m_bNeedReleaseParam)
		{
			ParamRelease<P_PARAM0> helper_;
			helper_.release(m_pParam0);
		}
	}

	void innerRun(RetTypeFlag<void>)
	{
		if (m_pTaskOwner && m_pFunc)
		{
			((*m_pTaskOwner).*m_pFunc)(m_pParam0);
		}

		if (m_bNeedReleaseParam)
		{
			ParamRelease<P_PARAM0> helper_;
			helper_.release(m_pParam0);
		}
	}

	virtual IRetStore* GetRetValue()
	{
		return &m_ret;
	}

	virtual void* GetRetValueNoRTTI()
	{
		return &m_ret;
	}


private:
	T_CLASS* m_pTaskOwner;
	FuncType m_pFunc;
	P_PARAM0 m_pParam0;
	bool m_bNeedReleaseParam;
	RetVauleStore<P_RETURN> m_ret;
};

template<class T_CLASS, typename P_RETURN, typename P_PARAM0, typename P_PARAM1>
class TaskViaParam2 : public IJSCallTask
{
public:
	typedef P_RETURN(T_CLASS::*FuncType)(P_PARAM0, P_PARAM1);
	TaskViaParam2(T_CLASS* pTaskOwner, FuncType pFunc, P_PARAM0 param0, P_PARAM1 param1, bool bNeedReleaseParam)
	{
		m_pTaskOwner = pTaskOwner;
		m_pFunc = pFunc;
		m_pParam0 = param0;
		m_pParam1 = param1;
		m_bNeedReleaseParam = bNeedReleaseParam;
	}

	TaskViaParam2()
	{
		m_pTaskOwner = NULL;
		m_pFunc = NULL;
		m_pParam0 = NULL;
		m_pParam1 = NULL;
		m_bNeedReleaseParam = false;
	}

	virtual ~TaskViaParam2()
	{
		if (m_pNotify)
		{
			m_pNotify->onReturnVauleNotify(GetRetValueNoRTTI());
			m_pNotify->onReturnVauleNotifyRTTI(GetRetValue());
			delete m_pNotify;
		}
	}

	virtual void Run()
	{
		innerRun(RetTypeFlag<P_RETURN>());
	}

	template<typename Type>
	void innerRun(RetTypeFlag<Type>)
	{
		if (m_pTaskOwner && m_pFunc)
		{
			m_ret.SetValue(((*m_pTaskOwner).*m_pFunc)(m_pParam0, m_pParam1));
		}

		if (m_bNeedReleaseParam)
		{
			ParamRelease<P_PARAM0> helper_0;
			helper_0.release(m_pParam0);

			ParamRelease<P_PARAM1> helper_1;
			helper_1.release(m_pParam1);
		}
	}

	void innerRun(RetTypeFlag<void>)
	{
		if (m_pTaskOwner && m_pFunc)
		{
			((*m_pTaskOwner).*m_pFunc)(m_pParam0, m_pParam1);
		}

		if (m_bNeedReleaseParam)
		{
			ParamRelease<P_PARAM0> helper_0;
			helper_0.release(m_pParam0);

			ParamRelease<P_PARAM1> helper_1;
			helper_1.release(m_pParam1);
		}
	}

	virtual IRetStore* GetRetValue()
	{
		return &m_ret;
	}

	virtual void* GetRetValueNoRTTI()
	{
		return &m_ret;
	}


private:
	T_CLASS* m_pTaskOwner;
	FuncType m_pFunc;
	P_PARAM0 m_pParam0;
	P_PARAM1 m_pParam1;
	bool m_bNeedReleaseParam;
	RetVauleStore<P_RETURN> m_ret;
};

template<class T_CLASS, typename P_RETURN, typename P_PARAM0, typename P_PARAM1, typename P_PARAM2>
class TaskViaParam3 : public IJSCallTask
{
public:
	typedef P_RETURN(T_CLASS::*FuncType)(P_PARAM0, P_PARAM1, P_PARAM2);
	TaskViaParam3(T_CLASS* pTaskOwner, FuncType pFunc, P_PARAM0 param0, P_PARAM1 param1, P_PARAM2 param2, bool bNeedReleaseParam)
	{
		m_pTaskOwner = pTaskOwner;
		m_pFunc = pFunc;
		m_pParam0 = param0;
		m_pParam1 = param1;
		m_pParam2 = param2;
		m_bNeedReleaseParam = bNeedReleaseParam;
	}

	TaskViaParam3()
	{
		m_pTaskOwner = NULL;
		m_pFunc = NULL;
		m_pParam0 = NULL;
		m_pParam1 = NULL;
		m_pParam2 = NULL;
		m_bNeedReleaseParam = false;
	}

	virtual ~TaskViaParam3()
	{
		if (m_pNotify)
		{
			m_pNotify->onReturnVauleNotify(GetRetValueNoRTTI());
			m_pNotify->onReturnVauleNotifyRTTI(GetRetValue());
			delete m_pNotify;
		}
	}

	virtual void Run()
	{
		innerRun(RetTypeFlag<P_RETURN>());
	}

	template<typename Type>
	void innerRun(RetTypeFlag<Type>)
	{
		if (m_pTaskOwner && m_pFunc)
		{
			m_ret.SetValue(((*m_pTaskOwner).*m_pFunc)(m_pParam0, m_pParam1, m_pParam2));
		}

		if (m_bNeedReleaseParam)
		{
			ParamRelease<P_PARAM0> helper_0;
			helper_0.release(m_pParam0);

			ParamRelease<P_PARAM1> helper_1;
			helper_1.release(m_pParam1);

			ParamRelease<P_PARAM2> helper_2;
			helper_2.release(m_pParam2);
		}
	}

	void innerRun(RetTypeFlag<void>)
	{
		if (m_pTaskOwner && m_pFunc)
		{
			((*m_pTaskOwner).*m_pFunc)(m_pParam0, m_pParam1, m_pParam2);
		}

		if (m_bNeedReleaseParam)
		{
			ParamRelease<P_PARAM0> helper_0;
			helper_0.release(m_pParam0);

			ParamRelease<P_PARAM1> helper_1;
			helper_1.release(m_pParam1);

			ParamRelease<P_PARAM2> helper_2;
			helper_2.release(m_pParam2);
		}
	}

	virtual IRetStore* GetRetValue()
	{
		return &m_ret;
	}

	virtual void* GetRetValueNoRTTI()
	{
		return &m_ret;
	}

private:
	T_CLASS* m_pTaskOwner;
	FuncType m_pFunc;
	P_PARAM0 m_pParam0;
	P_PARAM1 m_pParam1;
	P_PARAM2 m_pParam2;
	bool m_bNeedReleaseParam;
	RetVauleStore<P_RETURN> m_ret;
};

LRESULT CALLBACK myGetMsgProc(
	_In_ int    code,
	_In_ WPARAM wParam,
	_In_ LPARAM lParam
);

class CThreadAttach
{
public:
	CThreadAttach();
	~CThreadAttach();

	void Init(DWORD threadid);
	void Uninit();

	bool PostMsg(IJSCallTask* pMsg);


	void HandlerJSTask(IJSCallTask* pMsg);

private:
	HHOOK m_hook;
	CComAutoCriticalSection m_TaskLock;
	std::set<IJSCallTask*> m_TaskList;
	DWORD m_threadid;
};
#endif